# algorithm

## week_1(시공간 복잡도)

⏰ 시공간 복잡도에 대해서 알아본다.

### 시간 복잡도

시간 복잡도란 빅오에 대한 시간 개념으로 **알고리즘의 수행 시간**을 말한다. 

수행되는 연산의 수와 비례하여 실행시간이 증가하게되고 개발자가 짠 코드의 실행시간에 대하여 성능적으로 얼마나 효율적인지 평가하는 지표가 된다.

### 공간 복잡도

공간 복잡도란 공간에 대한 개념으로 **알고리즘이 메모리(공간)을 얼마나 필요**로 하는지를 말한다. 

주로 자료구조에서 자주 등장하는 개념으로 코드가 얼마나 메모리 공간을 효율적으로 사용하는지에 대한 평가 지표이다. 

<br>

시공간 표기법의 기본 크기의 순서는 아래와같다.

`O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!) < O(nⁿ)`

일반적으로 사용되는 대부분 함수의 경우(반복문을 사용하지 않고 return값이 바로 나오는) O(1)으로 표기된다.
반복문을 한번 사용하는 경우 O(n)으로 n번 연산을 하게된다라고 볼 수 있다.
따라서 중첩 반복문을 사용하면 할수록 아니면 큰 공간(2중배열 3중배열)에 대하여 반복문을 사용할 경우 n의 제곱으로 시간이 늘어나게된다.

예를 들어 두번의 반복문을 사용한다면 함수는 안에서 두번의 O(n)의 시간이 걸리는 연산을 시작하게 되므로 O(n^2)을 가지게된다. 

하지만 중첩 반복문을 사용할수록 시간복잡도가 늘어나는 경우는 일반적인 경우지만 다른 케이스도 분명 존재한다.

아래와 같은 경우는 N번의 반복을 하고 안에 while이라는 반복문을 가지고 있지만 또 배열을 순회하는 반복문이 아니기때문에 O(N)의 시공간 복잡도를 가진다.

```python
N = 1000

sum = 0
j = 0
for i in range(N):
    while j <= i:
        sum += 1
        j += 1
        
print(sum) # 1000
```

따라서 시간복잡도는 단순 반복문의 중첩으로 계산하는 것이 아니라 몇번 순회하느냐에 따라 계산하는 것이라 볼수있다.
   
<br>

## week_2(링크드 리스트, 재귀함수)

class에 대해 알아보고 linked_list를 구현해본다.

### class 

클래스란 커스텀이 가능한 객체에 대한 설계도이다. 주로 객체지향 프로그래밍에서 사용이 가능하며 클래스를 이용해 인스턴스(객체)를 만들어 사용한다.
생성자 안에서 어떤 속성들을 사용할 것인지, 어떤 매개를 받을 것인지 설계하고 안에 method들을 만들어 인스턴스 생성시 or 생성하지 않고 사용이 가능하다. 

### [linked_list](https://github.com/wjdghks963/algorithm/blob/master/week_2/01_print_all_linked_list.py)

링크드 리스트는 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료 구조이다. 
요즘은 언어들에서 컬렉션을 제공해 일반 list와 같이 쉽게 만들고 사용이 가능하다.

자신이 가질 값과 next라는 속성을 이용한 Node를 만들어서 구현이 가능하다.

링크드 리스트 자신의 클래스에는 head 속성, data 속성으로 만약 append method를 사용한다면 매개인 노드를 이전에 존재했던 Node의 next 속성에 넣어준다.

// 5의값 Node를 가지고 있는 LinkedList 인스턴스 생성, 이 값(Node(5))은 linkedlist의 head가 된다.
1. ll = LinkedList(5)
// n이라는 변수에 3의값 Node를 초기화
2. n = Node(3)
// LinkedList에 n이 들어가게된다. 여기서 ll 안에서 Node(5)의 next가 Node(3)이라는 값이 된다.
3. ll.append(n)

### 재귀함수

재귀함수란 함수 안에서 자기 자신을 반복적으로 실행하는 함수다. 


1. 자신을 종료하는 조건은 무조건 존재햐아한다.
2. 분기에 따라 원하는 조건에 따라 자기 자신을 다시 실행시킨다.
3. 순수함수가 요구된다. => 순수함수가 아닌경우 어떤 결과를 초래하게 될지 모른다.

대표적인 예로는 팩토리얼이 있다.

ex)
```python
def factorial(n):
    if n == 1:
        return 1
    return n * factorial(n - 1)

print(factorial(5))
```


   
## week_3(정렬, 스택, 큐, 해쉬)

[참고](https://brownbears.tistory.com/398)

### 정렬

최근에 등장한 언어들은 sort라는 메서드를 제공해준다. 간단하게 어떤것을 기준으로든 정렬이 가능하다.

⭐️ 정렬에는 대표적으로 bubble, selection, insert가 존재한다.

#### [버블 정렬](https://github.com/wjdghks963/algorithm/blob/master/week_3/01_buble_sort.py)

이웃되는 값끼리 비교하며 자리를 변경해나가는 방식이다.
기본적으로 시간복잡도는 O(n^2)를 가지며 대표적인 정렬 방법이다.

맨 처음 제일 큰값이 마지막 index에 위치하게 되며 뒤에서부터 순서가 정해지며 변경할 값이 없다면 종료된다.

#### [선택 정렬](https://github.com/wjdghks963/algorithm/blob/master/week_3/02_selection_sort.py)

오름차순 기준 0에서 부터 시작해 배열에서 가장 작은 값을 찾아 첫 index에 위치시킨다. 다음(1번째)부터 마지막까지 중 작은 값을 찾아 1번에 위치 시킨다. ....

버블 정렬보다 값을 전부 바꿔가며 진행하는 것이 아니라 index가 교체되는 회수가 적다. 반복문이 마지막 index에 도착한다면 종료된다.


#### [삽입 정렬](https://github.com/wjdghks963/algorithm/blob/master/week_3/03_insertion_sort.py)

두번째 자료부터 시작하여 그 앞의 자료들과 비교하여 삽입할 위치를 지정하고 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하는 정렬
여기서 자료는 단순히 index를 말하는 것이 아니다. 하나의 값이 될수도 정렬된 값의 배열일수도 있다.

1. index 1을 기준으로 0과 비교를 하고 첫번째 자료를 만든다.
2. 첫번째 정렬된 자료를 기준 다음 자료(index=2)와 비교하여 첫번째 정렬된 자료안에서 정렬을 한다. 이때 만약 순서를 바꾼다면 선택 정렬과 같이 자신보다 낮은 값 다음으로 위치가 변경된다.
3. 이것들이 계속 반복되며 마지막 자료까지 전 자료에 들어가 정렬된다면 정렬이 종료된다.


#### [합병 정렬](https://github.com/wjdghks963/algorithm/blob/master/week_3/05_merge_sort.py)

하나의 리스트를 두개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 후 두개의 리스트를 합해 정렬한다.

1. 빈 리스트를 하나 만든다.
2. 배열할 리스트를 둘로 나눈다.
3. 둘로 나뉜 배열에서 각각 첫번째 index 부터 작은 수를 찾아 빈 리스트에 담는다. 이때 작은 수는 양쪽 리스트에서 비교하며 받아온다.
4. 정렬된 값으로 채워진 리스트를 원래의 배열에 옮긴다.

<br>

### [Stack](https://github.com/wjdghks963/algorithm/blob/master/week_3/06_stack.py)

스택은 선입후출 자료구조다.

스택의 연산은 아래와 같다.

- pop : 스택에서 제일 위에 있는 값을 **제거**
- peek : 스택의 가장 위에 있는 값을 **반환** 제거(❌) 
- push : 스택의 제일 위에 값을 추가
- isEmpty : 스택이 비어있을 때 true 반환

출력순서가 입력 순서의 역순으로 이루어질때 자주 사용한다.


### [Queue](https://github.com/wjdghks963/algorithm/blob/master/week_3/08_queue.py)

큐는 선입선출 자료구조다.

큐의 연산은 아래와 같다.

- remove : 가장 밑에 있는 값(첫번째)을 **제거**
- peek : 가장 밑에 있는 값(첫번째)을 **반환** 제거(❌) 
- add : 가장 위에 있는 값(맨 마지막)에 값을 추가
- isEmpty : 큐가 비어있을 때 true 반환

### Hash

데이터를 효율적으로 관리하기 위해 임의의 길이 데이터를 고정된 길이의 데이터로 매핑하는 것

해시값을 주소로 사용해 데이터를 저장한다. 리스트로 비교한다면 자료에 index를 부여하는 것과 같다. 해당 index를 이용해 값을 구분할 수 있다.

🍪 얕은 복사를 본다면 데이터의 주소값을 복사해 같은 값을 다른 변수에서 사용해 해당 데이터에 접근하는 것이다. 이때 주소값으로 해시를 이용한다.

해시를 사용한다면 적은 자원으로 많은 데이터를 효율적으로 관리할 수 있다.

<br>
   
## week_4(트리, 힙, 그래프, DFS & BFS, Dynamic Programming)

### 그래프

Node, Edge(간선)로 이루어진 자료구조

- 방향, 무방향 그래프
- 루트(시작점)이 존재하지 않는다.
- 부모-자식 관계가 존재하지 않는다.
- 그래프에 따라 간선의 수가 다르다.


### 트리

그래프의 한 종류 (방향 그래프)

트리는 Node와 Node를 이어주는 Edge로 이루어져있다. 트리의 시작인 Node는 root라고 부른다.

트리에서 모든 노드들은 0개 이상의 자식 노드들을 가지고 있으며 부모-자식 관계를 가지고 있다.

#### 특징

- 트리에는 사이클이 존재하지 않는다.
- 모든 Node는 자료형으로 표현이 가능하다.
- root에서 하나의 Node로 가능 경로는 유일한 경로 밖에 존재하지 않는다.
- Node의 개수가 N개라면 Edge는 N-1개를 가진다.


### Heap

우선순위 queue를 위해 만들어진 자료구조

우선순위 queue란 데이터들이 우선순위를 가지고 있고 우선순위가 높은 데이터가 먼저 나간다.

완전 이진 트리의 일종이다. 일반 이진 탐색 트리와 다르게 중복된 값을 허용한다.

<br>
<br>

### [DFS](https://github.com/wjdghks963/algorithm/blob/master/week_4/03_DFS_stack.py)

깊이 우선 탐색은 root로 부터 시작해 인접한 노드를 먼저 탐색하는 방법

시작점으로부터 다음 branch로 넘어가기 전에 해당 branch에 존재하는 노드들을 완벽하게 탐색하고 넘어가는 방법

노드 방문시 방문 여부를 반드시 검사해야한다.

재귀나 스택으로 구현 가능하다.


1. 그래프, 시작점을 매개로 받는다.
2. 방문한 노드를 확인할 수 있는 리스트(V), 시작점을 가지고 있는 리스트(F)를 만든다.
3. F가 빌때 까지 반복문을 시작한다. V에 시작점을 넣는다.
4. 시작점으로 시작하며 만약 시작하는 노드와 연결되어 있는 노드들이 V에 없다면 F에 노드를 추가한다.

대표적으로 가장 깊은 노드까지의 거리를 구하는 문제가 있다.

인자로 그래프를 받는다.

```javascript
fucntion maxDepth(root){
    if(root === null) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right))+1;
}
```

만약 왼,오른쪽에 대한 값이 없으면 0을 반환한다.

최대 깊이를 구하는 것이기 때문에 양쪽 값이 존재하는지 확인하고 0이 아닌 값을 max로 잡고 더 큰 값을 찾는다.
만약 root가 null이 아니라면 1은 무조건 갖는 값이 되기 때문에 +1를 붙여준다.



### [BFS](https://github.com/wjdghks963/algorithm/blob/master/week_4/04_bfs_queue.py)

넓이 우선 탐색은 root에서 시작해 인접한 노드를 먼저 탐색하는 방법

시작 정점부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법 => 깊이보다 넓이를 우선시하며 탐색한다.

큐를 사용해서 구현이 가능하다.

1. 그래프, 시작점을 매개로 받는다.
2. 방문한 노드를 확인할 수 있는 리스트(V), 시작점을 가지고 있는 리스트(F)를 만든다.
3. F가 빌때 까지 반복문을 시작한다. V에 시작점을 넣는다.
4. 시작점으로 시작하며 만약 시작하는 노드와 연결되어 있는 노드들이 V에 없다면 F에 노드를 추가한다.



## week_5

  문제풀이


</br> 
</br>  

공부하는 곳

</br>  

1. 프로그래머스(https://programmers.co.kr/)

JS 1래벨 완료
2래밸 진행 중

2. 코드시그널(https://app.codesignal.com/interview-practice)

3. 해커랭크(https://www.hackerrank.com/dashboard)
