# algorithm

## week_1(시공간 복잡도)

⏰ 시공간 복잡도에 대해서 알아본다.

### 시간 복잡도

시간 복잡도란 빅오에 대한 시간 개념으로 **알고리즘의 수행 시간**을 말한다. 

수행되는 연산의 수와 비례하여 실행시간이 증가하게되고 개발자가 짠 코드의 실행시간에 대하여 성능적으로 얼마나 효율적인지 평가하는 지표가 된다.

### 공간 복잡도

공간 복잡도란 공간에 대한 개념으로 **알고리즘이 메모리(공간)을 얼마나 필요**로 하는지를 말한다. 

주로 자료구조에서 자주 등장하는 개념으로 코드가 얼마나 메모리 공간을 효율적으로 사용하는지에 대한 평가 지표이다. 

<br>

시공간 표기법의 기본 크기의 순서는 아래와같다.

`O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!) < O(nⁿ)`

일반적으로 사용되는 대부분 함수의 경우(반복문을 사용하지 않고 return값이 바로 나오는) O(1)으로 표기된다.
반복문을 한번 사용하는 경우 O(n)으로 n번 연산을 하게된다라고 볼 수 있다.
따라서 중첩 반복문을 사용하면 할수록 아니면 큰 공간(2중배열 3중배열)에 대하여 반복문을 사용할 경우 n의 제곱으로 시간이 늘어나게된다.

예를 들어 두번의 반복문을 사용한다면 함수는 안에서 두번의 O(n)의 시간이 걸리는 연산을 시작하게 되므로 O(n^2)을 가지게된다. 

하지만 중첩 반복문을 사용할수록 시간복잡도가 늘어나는 경우는 일반적인 경우지만 다른 케이스도 분명 존재한다.

아래와 같은 경우는 N번의 반복을 하고 안에 while이라는 반복문을 가지고 있지만 또 배열을 순회하는 반복문이 아니기때문에 O(N)의 시공간 복잡도를 가진다.

```python
N = 1000

sum = 0
j = 0
for i in range(N):
    while j <= i:
        sum += 1
        j += 1
        
print(sum) # 1000
```

따라서 시간복잡도는 단순 반복문의 중첩으로 계산하는 것이 아니라 몇번 순회하느냐에 따라 계산하는 것이라 볼수있다.
   
<br>

## week_2(링크드 리스트, 재귀함수)

class에 대해 알아보고 linked_list를 구현해본다.

### class 

클래스란 커스텀이 가능한 객체에 대한 설계도이다. 주로 객체지향 프로그래밍에서 사용이 가능하며 클래스를 이용해 인스턴스(객체)를 만들어 사용한다.
생성자 안에서 어떤 속성들을 사용할 것인지, 어떤 매개를 받을 것인지 설계하고 안에 method들을 만들어 인스턴스 생성시 or 생성하지 않고 사용이 가능하다. 

### [linked_list](https://github.com/wjdghks963/algorithm/blob/master/week_2/01_print_all_linked_list.py)

링크드 리스트는 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료 구조이다. 
요즘은 언어들에서 컬렉션을 제공해 일반 list와 같이 쉽게 만들고 사용이 가능하다.

자신이 가질 값과 next라는 속성을 이용한 Node를 만들어서 구현이 가능하다.

링크드 리스트 자신의 클래스에는 head 속성, data 속성으로 만약 append method를 사용한다면 매개인 노드를 이전에 존재했던 Node의 next 속성에 넣어준다.

// 5의값 Node를 가지고 있는 LinkedList 인스턴스 생성, 이 값(Node(5))은 linkedlist의 head가 된다.
1. ll = LinkedList(5)
// n이라는 변수에 3의값 Node를 초기화
2. n = Node(3)
// LinkedList에 n이 들어가게된다. 여기서 ll 안에서 Node(5)의 next가 Node(3)이라는 값이 된다.
3. ll.append(n)

### 재귀함수

재귀함수란 함수 안에서 자기 자신을 반복적으로 실행하는 함수다. 


1. 자신을 종료하는 조건은 무조건 존재햐아한다.
2. 분기에 따라 원하는 조건에 따라 자기 자신을 다시 실행시킨다.
3. 순수함수가 요구된다. => 순수함수가 아닌경우 어떤 결과를 초래하게 될지 모른다.

대표적인 예로는 팩토리얼이 있다.

ex)
```python
def factorial(n):
    if n == 1:
        return 1
    return n * factorial(n - 1)

print(factorial(5))
```


   
## week_3(정렬, 스택, 큐, 해쉬)

[참고](https://brownbears.tistory.com/398)

### 정렬

최근에 등장한 언어들은 sort라는 메서드를 제공해준다. 간단하게 어떤것을 기준으로든 정렬이 가능하다.

⭐️ 정렬에는 대표적으로 bubble, selection, insert가 존재한다.

#### [버블 정렬](https://github.com/wjdghks963/algorithm/blob/master/week_3/01_buble_sort.py)

이웃되는 값끼리 비교하며 자리를 변경해나가는 방식이다.
기본적으로 시간복잡도는 O(n^2)를 가지며 대표적인 정렬 방법이다.

맨 처음 제일 큰값이 마지막 index에 위치하게 되며 뒤에서부터 순서가 정해지며 변경할 값이 없다면 종료된다.

#### [선택 정렬](https://github.com/wjdghks963/algorithm/blob/master/week_3/02_selection_sort.py)

오름차순 기준 0에서 부터 시작해 배열에서 가장 작은 값을 찾아 첫 index에 위치시킨다. 다음(1번째)부터 마지막까지 중 작은 값을 찾아 1번에 위치 시킨다. ....

버블 정렬보다 값을 전부 바꿔가며 진행하는 것이 아니라 index가 교체되는 회수가 적다. 반복문이 마지막 index에 도착한다면 종료된다.


#### [삽입 정렬](https://github.com/wjdghks963/algorithm/blob/master/week_3/03_insertion_sort.py)

두번째 자료부터 시작하여 그 앞의 자료들과 비교하여 삽입할 위치를 지정하고 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하는 정렬
여기서 자료는 단순히 index를 말하는 것이 아니다. 하나의 값이 될수도 정렬된 값의 배열일수도 있다.

1. index 1을 기준으로 0과 비교를 하고 첫번째 자료를 만든다.
2. 첫번째 정렬된 자료를 기준 다음 자료(index=2)와 비교하여 첫번째 정렬된 자료안에서 정렬을 한다. 이때 만약 순서를 바꾼다면 선택 정렬과 같이 자신보다 낮은 값 다음으로 위치가 변경된다.
3. 이것들이 계속 반복되며 마지막 자료까지 전 자료에 들어가 정렬된다면 정렬이 종료된다.


#### [합병 정렬](https://github.com/wjdghks963/algorithm/blob/master/week_3/05_merge_sort.py)

하나의 리스트를 두개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 후 두개의 리스트를 합해 정렬한다.

1. 빈 리스트를 하나 만든다.
2. 배열할 리스트를 둘로 나눈다.
3. 둘로 나뉜 배열에서 각각 첫번째 index 부터 작은 수를 찾아 빈 리스트에 담는다. 이때 작은 수는 양쪽 리스트에서 비교하며 받아온다.
4. 정렬된 값으로 채워진 리스트를 원래의 배열에 옮긴다.

<br>

### [Stack](https://github.com/wjdghks963/algorithm/blob/master/week_3/06_stack.py)

스택은 선입후출 자료구조다.

스택의 연산은 아래와 같다.

- pop : 스택에서 제일 위에 있는 값을 **제거**
- peek : 스택의 가장 위에 있는 값을 **반환** 제거(❌) 
- push : 스택의 제일 위에 값을 추가
- isEmpty : 스택이 비어있을 때 true 반환

출력순서가 입력 순서의 역순으로 이루어질때 자주 사용한다.


### [Queue](https://github.com/wjdghks963/algorithm/blob/master/week_3/08_queue.py)

큐는 선입선출 자료구조다.

큐의 연산은 아래와 같다.

- remove : 가장 밑에 있는 값(첫번째)을 **제거**
- peek : 가장 밑에 있는 값(첫번째)을 **반환** 제거(❌) 
- add : 가장 위에 있는 값(맨 마지막)에 값을 추가
- isEmpty : 큐가 비어있을 때 true 반환

   
## week_4

   트리, 힙, 그래프, DFS & BFS, Dynamic Programming
   
## week_5

  문제풀이


</br> 
</br>  

공부하는 곳

</br>  

1. 프로그래머스(https://programmers.co.kr/)

JS 1래벨 완료
2래밸 진행 중

2. 코드시그널(https://app.codesignal.com/interview-practice)

3. 해커랭크(https://www.hackerrank.com/dashboard)
